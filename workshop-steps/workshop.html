<!DOCTYPE html>
<!-- saved from url=(0060)http://getbootstrap.com/2.3.2/examples/starter-template.html -->
<html lang="fr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Streaming Data Workshop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Le styles -->
  <link href="styles/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="styles/idea.css">
  <style type="text/css">
    body {
      padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
    }
    section {
      padding-bottom: 20px;
    }
    li {
      margin: 10px;
    }
    pre {
      background-color: white;
    }
    .btn {
      margin-top: 5px;
      margin-bottom: 5px;
    }
  </style>
  <script src="js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body cz-shortcut-listen="true">

<div class="navbar navbar-inverse navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="navbar-brand" href="#">
        Streaming Data Workshop
      </a>
      <div class="nav-collapse collapse">
        <ul class="nav">
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div class="container">
  <h1>Installation Steps</h1>
  To do this workshop, it's necessary to have some components installed in the local machine.
  Depending on your environment, you can find detailed installation instructions below:

  <h2>Restricted Internet Environment</h2>
  If you're in an environment with restricted internet connection (e.g. conference or public wifi), we have prepared a virtual box for you to run this workshop.
  This image contains all the dependencies and tools you need to run the workshop so that your internet connectivity requirements are minimized.
  The installation steps in this case involve installing Virtual Box 5.1 and setting it up so that it's adjusted to your environment.
  <br/><br/>
  Start by installing Virtual Box 5.1.
  <br/><br/>
  <div class="alert alert-warning" role="alert">
    For Windows or Mac users, you should be able to just install them from the given files.
    <br/>
    However, for those running Unix/Linux environments, the pen drive contains Virtual Box packages but you might need to download and install dependencies separately.
  </div>
  Once the installation has completed, import the provided image into Virtual Box and adjust it for your environment:

  <div class="alert alert-info" role="alert">
    If using a trackpad, it is recommended to switch the <code>Pointing Device</code> to <code>USB Multi-Touch Tablet</code>.
    <br/>
    To do that, right click on the imported image and select <code>Settings</code>.
    Then, go to <code>System</code> and apply the change there. Here's an screenshot to guide you:
    <br/><br/>
    <img src="img/multi-touch.png" class="img-rounded" height="75%" width="75%">
  </div>

  For a smooth experience on your environment, it is recommended that Virtual Box Guest Additions are installed.
  To install them, you first need to add an optical drive to your image (if none present).
  <br/><br/>
  <img src="img/add-optical-drive.png" class="img-rounded" height="50%" width="50%">
  <br/><br/>

  Once you add it, initialize as empty by choosing <code>Leave empty</code>.
  <br/><br/>
  <img src="img/leave-empty.png" class="img-rounded" height="30%" width="30%">
  <br/><br/>

  To be able to copy/paste text from your environment to the virtual machine, you should enable <code>Shared Clipboard</code> by setting it to be <code>Bidirectional</code>.
  This can be done via the <code>General / Advanced</code> tab in <code>Settings</code>
  <br/><br/>
  <img src="img/bidirectional-clipboard.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Next, select the virtual machine and click on <code>Start</code>.
  When the virtual machine starts, type in <code>developer</code> as password.
  <br/><br/>

  When you start the virtual machine first time, the virtual machine will ask to choose the panel configuration.
  In this dialog, you should choose <code>Use default config</code>.
  <br/><br/>
  <img src="img/panel-default-config.png" class="img-rounded" height="30%" width="30%">
  <br/><br/>

  Next, you will use the optical drive added earlier to install the Virtual Box Guest Additions.
  These are necessary for you to be able to go full screen with the virtual machine.
  With the image started, click on <code>Devices / Install Guest Additions CD image</code>.
  If the CD does not autorun, you can install the guest additions from the <code>Terminal</code> by executing the following commands:
  <br/><br/>

  <pre><code>> cd /run/media/developer/VBOXADDITIONS_5.1.30_118389
> sudo sh ./VBoxLinuxAdditions.run</code></pre>

  <img src="img/install-additions-cmd-line.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  <div class="alert alert-warning" role="alert">
    Make sure you <strong>reboot the virtual machine</strong> after installing the guest additions for the changes to take effect.
  </div>

  From the time the virtual machine is created and the workshop is delivered, there might have been updates to code or steps.
  To update the virtual machine with the latest workshop changes, open the <code>Terminal</code> and execute:
  <br/><br/>
  <pre><code>> cd streaming-data-workshop
> git fetch origin
> git pull</code></pre>
  <br/>
  <img src="img/update-workshop.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  <div class="alert alert-danger" role="alert">
    If you're running this workshop <strong>completely offline</strong>, you need to adjust <code>/etc/hosts</code> file so that host names can be resolved locally:
    <br/><br/>
    <pre><code>127.0.0.1        datagrid-visualizer-myproject.127.0.0.1.nip.io
127.0.0.1        delayed-listener-myproject.127.0.0.1.nip.io
127.0.0.1        delayed-trains-myproject.127.0.0.1.nip.io
127.0.0.1        workshop-main-myproject.127.0.0.1.nip.io</code></pre>
  </div>

  Finally, to help develop code, the virtual machine comes with both Eclipse and Intellij IDEA installed by default.
  These are accessible via <code>Applications / Development</code>.
  <br/><br/>
  <img src="img/ides-in-vm.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  <h3>Importing workshop into IntelliJ IDEA in virtual machine</h3>

  Start by clicking on <code>Intellij IDEA</code> located in <code>Applications / Development</code>.
  First time it runs, you will need to click on <code>Accept</code> in the JetBrains Privacy Policy dialog.
  Then, from the starting menu, select <code>Import Project</code>:
  <br/><br/>
  <img src="img/intellij-import-project.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Next, select the <code>/home/developer/streaming-data-workshop/pom.xml</code> file and click <code>OK</code>:
  <br/><br/>
  <img src="img/intellij-select-pom.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  In the next dialog entries, click <code>Next</code> until you get to dialog to select an SDK.
  Click on the <code>+</code> sign and select <code>JDK</code>:
  <br/><br/>
  <img src="img/intellij-add-new-sdk.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Then, let Intellij IDEA select the default location for the JDK and click <code>OK</code>:
  <br/><br/>
  <img src="img/intellij-default-jdk-location.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  <div class="alert alert-warning" role="alert">
    When Intellij IDEA completes loading the project, you might see a warning saying that the current inotify watch limit is low.
    You can ignore this warning message.
    <br/><br/>
    <img src="img/intellij-inotify-warning.png" class="img-rounded" height="75%" width="75%">
    <br/><br/>
  </div>

  Click <code>Next</code> and in next dialog click <code>Finish</code>

  <h3>Importing Workshop Into Eclipse in Virtual Machine</h3>

  Start by clicking on <code>Eclipse</code> located in <code>Applications / Development</code>.
  Next, select the default workspace location suggested by Eclipse:
  <br/><br/>
  <img src="img/eclipse-default-workspace.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  When Eclipse starts, select <code>File / Import</code>:
  <br/><br/>
  <img src="img/eclipse-import.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Then, select <code>Maven</code> and within it, <code>Existing Maven Projects</code> and click <code>Next</code>:
  <br/><br/>
  <img src="img/eclipse-existing-maven-projects.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Next, navigate to <code>/home/developer/streaming-data-workshop</code> and press <code>OK</code>:
  <br/><br/>
  <img src="img/eclipse-project-home.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  Eclipse should discover all the modules within the workshop, so just click <code>Finish</code>:
  <br/><br/>
  <img src="img/eclipse-finish-import.png" class="img-rounded" height="75%" width="75%">
  <br/><br/>

  <div class="alert alert-warning" role="alert">
    Eclipse might next report a message saying that no marketplace entries are found for <code>vertx-maven-plugin</code>.
    Just click on <code>Resolve All Later</code> and <code>Finish</code>:
    <br/><br/>
    <img src="img/eclipse-maven-plugin-connectors.png" class="img-rounded" height="75%" width="75%">
    <br/><br/>

    If Eclipse says that continuing with import might result with build errors, just ignore it and click <code>OK</code>:
    <br/><br/>
    <img src="img/eclipse-ignore-errors-confirmation.png" class="img-rounded" height="75%" width="75%">
    <br/><br/>

    After doing this, you might see some errors in the project, you can simply ignore them or click on each of the errors select <code>Delete</code>
    <br/><br/>
    <img src="img/eclipse-ignore-errors-project.png" class="img-rounded" height="75%" width="75%">
    <br/><br/>
  </div>

  <h2>Unrestricted Internet Environment</h2>
  If you are in an environment with unrestricted internet connection (e.g. home or office), you can run this workshop directly on your machine.
  These are the dependencies that you need to have installed and available in your path:
  <ul>
    <li>Docker version 1.13.1. If you have a newer Docker version installed, the workshop might still work but can't provide guarantees.</li>
    <li><a href="https://github.com/openshift/origin/releases/tag/v3.6.1">OpenShift Client 3.6</a></li>
    <li><a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.6.11">Kubernetes 1.6</a></li>
    <li><a href="https://github.com/johanhaleby/kubetail/tree/1.2.1">Kubetail 1.2.1</a></li>
    <li><a href="https://github.com/creationix/nvm">Node.js Version Manager</a>.
      Makes it easy to work with multiple Node.js versions</li>
  </ul>
  After installing these dependencies, start the Docker daemon.

</div>

<div class="container">
  <h1>Playground</h1>

  <p>We will start with a warm-up for those that are not familiar with <strong>Eclipse Vert.x</strong>, <strong>Infinispan</strong> and <strong>Openshift</strong>.</p>

  <div class="alert alert-success" role="alert">
    <h4 class="alert-heading">What is OpenShift?</h4>
    OpenShift is Red Hat's Platform-as-a-Service (Paas) that allows developers to quickly develop, host, and scale apps in a cloud environment.
    It uses Kubernetes for the orchestration of Docker containers where applications run.
    It can be run in a public environment or privately within your organization.
    You can run applications written in multiple languages such as Ruby, Javascript, Python...etc.
    <hr/>
    <h4 class="alert-heading">What will OpenShift be used for in the workshop?</h4>
    OpenShift will be used as the environment for running most of the components of this workshop.
    As you work through the exercises, you will learn how to deploy applications to it.
  </div>

  <h2>Ex1 :: Start Openshift and Create an Infinispan Cluster</h2>
  <section id="openshift">
    <img src="img/openshift.png" alt="Openshift" class="img-rounded" height="30%" width="30%">
    <ul style="list-style: decimal;">
      <li>Start a cluster with the service catalog</li>
      <pre><code>> cd streaming-data-workshop
> ./start-openshift.sh</code></pre>
      <li>Log in into <a href="https://127.0.0.1:8443" target="_blank">Openshift console</a> with <code>developer/developer</code></li>
      <li>Click in "browse catalog"</li>
    </ul>
    <img src="img/openshift-catalog.png" alt="simple web app" class="img-rounded"/>
  </section>

  <section id="infinispan">
    <img src="img/infinispan9_pixelsizes_600.gif" alt="Infinispan" class="img-rounded" height="20%" width="20%">
    <ul style="list-style: decimal;">
      <li>In openshift catalog, choose <kbd>Infinispan Ephemeral</kbd></li>
      <li>Add the following configuration :
          <pre><code>APPLICATION_NAME=datagrid
NUMBER_OF_INSTANCES=3
MANAGEMENT_USER/MANAGEMENT_PASSWORD=developer/developer</code></pre>
      </li>
      <li>Click <kbd>Next</kbd></li>
      <li>Click <kbd>Create</kbd></li>
      <li>Go to <kbd>My project</kbd></li>
      <li>You should see <kbd>datagrid</kbd> deployment with <kbd>3 pods</kbd> and <kbd>3 services</kbd> : datagrid-hotrod, datagrid-http and datagrid-management
      <img src="img/datagrid-pods.png" alt="pods" class="img-rounded"/>
      <div class="alert alert-warning">Alternatively, you can deploy de cluster easily from command line :</div>
      <pre><code>cd streaming-data-workshop
./start-datagrid.sh</code></pre></li>
      <li>Deploy all the components for the workshop with <code>./deploy-all.sh</code></strong></li>
      <li>Check the <strong>Infinispan Visualizer</strong> <a href="http://datagrid-visualizer-myproject.127.0.0.1.nip.io/infinispan-visualizer/" target="_target">here</a>
        <br/>
        <p>The image here corresponds to the state of 3 instances without data.</p>
        <img src="img/infinispan-visu.png" alt="visualizer" class="img-rounded"/>
      </li>
    </ul>
  </section>

  <h1>Streaming Data</h1>

  <h2>Ex3 :: Start</h2>
  <ul>
    <li>Go to the board : <a href="http://localhost:3000/" target="_target">front-end app</a></li>
    <li>An empty map should be displayed. Otherwise make sure the <code>web-viewer</code> app is started: <code>cd ./web-viewer; ./start.sh</code></li>
  </ul>

  <h2>Ex4 :: Collect data</h2>

  <p>In this section we are going to import in a reactive and real-time way a file that contains data.
  This code would work connecting to a remote web-service or any other data source. The data collected in the files are real data coming from
  an real API on Swiss Transport.</p>


  <h3>Make data injection work</h3>

  <section id="inject">
    <img src="img/collectionLayer.png" alt="Collection Layer" class="img-rounded">
    <ul style="list-style: decimal;">
      <li>Open <kbd>StationsInjector</kbd></li>
      <li>Implement <code>inject</code> method with RxJava
        <pre><code class="java">router.get(STATIONS_INJECTOR_URI).handler(this::inject);

private void inject(RoutingContext ctx) {
    vertx. < RemoteCache < String, Stop>>rxExecuteBlocking(fut -> fut.complete(client.getCache(STATION_BOARDS_CACHE_NAME)))
      // Remove data on start, to start clean
      .map(stations -> fromFuture(stations.clearAsync()).to(x -> stations))
      .subscribe(stations -> {
        vertx.setPeriodic(5000L, l ->
          vertx.executeBlocking(fut -> {
            log.info(String.format("Progress: stored=%d%n", stations.size()));
            fut.complete();
          }, false, ar -> {}));

        Observable<String> fileObservable = rxReadGunzippedTextResource("cff-stop-2016-02-29__.jsonl.gz");

        // TODO 1: map each entry of the observable into a tuple of String/Stop with StationsInjector::toEntry
        Observable<Map.Entry<String, Stop>> pairObservable = null;

        // TODO 2. for each entry, store it in the stations cache calling putAsync
        Observable<?> putObservable = null;

        putObservable.subscribe(Actions.empty(),
            t -> log.log(SEVERE, "Error while loading", t));

        ctx.response().end("Injector started");
      });
  }
        </code></pre>

        <ul>
          <li><kbd>TODO 1</kbd> Map each entry into a tuple of String/Stop with <code>StationsInjector::toEntry</code>
            <br/><a class="btn btn-info" role="button" onclick="$('#array-sol-13').toggle();">Show/Hide Solution</a>
            <div id="array-sol-13" style="display:none;">
              <pre><code class="java">Observable<Map.Entry<String, Stop>> pairObservable = fileObservable.map(StationsInjector::toEntry);</code></pre></div>
          </li>
          <li><kbd>TODO 2</kbd> For each entry, store it in the stations cache calling <code>putAsync</code>
            <br/><a class="btn btn-info" role="button" onclick="$('#array-sol-14').toggle();">Show/Hide Solution</a>
            <div id="array-sol-14" style="display:none;">
              <pre><code class="java">Observable<?> putObservable = pairObservable.doOnNext(e -> stations.putAsync(e.getKey(), e.getValue()));</code></pre></div>
          </li>
        </ul>

        <a class="btn btn-danger" role="button" onclick="$('#array-sol-3').toggle();">Show/Hide Final Solution</a>
        <div id="array-sol-3" style="display:none;">
          <div class="alert alert-info" role="alert">
            You can deploy the solution by either of these two methods:
            <ul>
              <li>Copy/pasting the code and call: <code>mvn fabric8:deploy</code></li>
              <li>Or simply call <code>mvn fabric8:deploy -Psolution</code></li>
            </ul>
          </div>
        <pre>
          <code class="java">private void inject(RoutingContext ctx) {
    vertx.< RemoteCache < String , Stop > >rxExecuteBlocking(fut -> fut.complete(client.getCache(STATION_BOARDS_CACHE_NAME)))
      // Remove data on start, to start clean
      .map(stations -> fromFuture(stations.clearAsync()).to(x -> stations))
      .subscribe(stations -> {
        vertx.setPeriodic(5000L, l ->
          vertx.executeBlocking(fut -> {
            log.info(String.format("Progress: stored=%d%n", stations.size()));
            fut.complete();
          }, false, ar -> {}));

        Observable<String> fileObservable = rxReadGunzippedTextResource("cff-stop-2016-02-29__.jsonl.gz");

        Observable<Map.Entry<String, Stop>> pairObservable =
            fileObservable.map(StationsInjector::toEntry);

        Observable<?> putObservable =
            pairObservable.doOnNext(e -> stations.putAsync(e.getKey(), e.getValue()));

        putObservable.subscribe(Actions.empty(),
          t -> log.log(SEVERE, "Error while loading", t));

        ctx.response().end("Injector started");
      });
}</code></pre>
        </div>
      </li>
      <li>From command line, change directory to <code>stations-injector</code> and redeploy with <code>mvn fabric8:deploy</code></li>
      <li>Force the injection start the injection with <code>curl http://workshop-main-myproject.127.0.0.1.nip.io/inject</code></li>
      <li>Go to the <a href="http://datagrid-visualizer-myproject.127.0.0.1.nip.io/infinispan-visualizer/" target="_target"> visualizer</a> and see data being loaded.
        <div class="alert alert-info">
          If you don't see data being loaded, make sure <code>stations</code> cache selected in the drop down of the visualizer.
          It might take a few seconds for data to appear in the visualizer, so be patient :)
        </div>
      </li>
    </ul>
    <br/>
    <p>The image here corresponds to the state of 3 instances having data.</p>
    <img src="img/infinispan-visu-loading.png" alt="visualizer" class="img-rounded"/>

  </section>


  <h2>Ex5 :: Transport data</h2>

  <section id="transport">
    <img src="img/transportLayer.png" alt="Transport Layer" class="img-rounded">
    <ul style="list-style: decimal;">
      <li>Open <kbd>DelayedListener</kbd> class in the <kbd>delayed-listener</kbd> module</li>
      <li>Implement <code>inject</code> method with <strong>continuous query</strong>
        <pre><code class="java">private void addContinuousQuery(RemoteCache< String, Stop> stations) {
    QueryFactory queryFactory = Search.getQueryFactory(stations);

    // TODO 1 - Create query for Stop where delayMin is bigger than 0
    Query query = null;

    ContinuousQueryListener<String, Stop> listener =
      new ContinuousQueryListener<String, Stop>() {
        @Override
        public void resultJoining(String id, Stop stop) {
          String stopAsJson = toJson(stop);
          // TODO 2 - Publish stopAsJson to "delayed-trains" event-bus address
          // ...

          RemoteCache<String, String> delayed = client.getCache(DELAYED_TRAINS_CACHE_NAME);
          delayed.putAsync(stop.train.getName(), stop.train.getName());
        }
      };

    ContinuousQuery<String, Stop> continuousQuery = Search.getContinuousQuery(stations);
    continuousQuery.removeAllListeners();

    // TODO 3 - Join query with listener
    // ...
  }</code></pre>

        <ul>
          <li><kbd>TODO 1</kbd> Create query for <code>Stop</code> where <strong>delayMin</strong> is bigger than 0 using the <code>QueryFactory</code>
            <br/><a class="btn btn-info" role="button" onclick="$('#array-sol-17').toggle();">Show/Hide Solution</a>
            <div id="array-sol-17" style="display:none;">
              <pre><code class="java"> Query query = queryFactory.from(Stop.class).having("delayMin").gt(0L).build();</code></pre></div>
          </li>
          <li><kbd>TODO 2</kbd> Implement the <code>resultJoining</code> method so that it publish each new Stop as JSON to the <strong>"delayed-trains"</strong> address via Vert.x eventbus
            <br/><a class="btn btn-info" role="button" onclick="$('#array-sol-18').toggle();">Show/Hide Solution</a>
            <div id="array-sol-18" style="display:none;">
              <pre><code class="java"> vertx.eventBus().publish("delayed-trains", stopAsJson);</code></pre></div>
          </li>
          <li><kbd>TODO 3</kbd> Finish the <code>addContinuousQuery</code> method joining the query with continuous query listener
            <br/><a class="btn btn-info" role="button" onclick="$('#array-sol-19').toggle();">Show/Hide Solution</a>
            <div id="array-sol-19" style="display:none;">
              <pre><code class="java"> continuousQuery.addContinuousQueryListener(query, listener);</code></pre></div>
          </li>
        </ul>

        <a class="btn btn-danger" role="button" onclick="$('#array-sol-4').toggle();">Show/Hide Final Solution</a>
        <div id="array-sol-4" style="display:none;">
          <div class="alert alert-info" role="alert">
            You can deploy the solution by either of these two methods:
            <ul>
              <li>Copy/pasting the code and call: <code>mvn fabric8:deploy</code></li>
              <li>Or simply call <code>mvn fabric8:deploy -Psolution</code></li>
            </ul>
          </div>
        <pre>
          <code class="java">private void addContinuousQuery(RemoteCache< String, Stop> stations) {
    QueryFactory qf = Search.getQueryFactory(stations);

    Query query = qf.from(Stop.class)
      .having("delayMin").gt(0L)
      .build();

    ContinuousQueryListener<String, Stop> listener =
      new ContinuousQueryListener<String, Stop>() {
        @Override
        public void resultJoining(String id, Stop stop) {
          JsonObject stopAsJson = toJson(stop);
          vertx.eventBus().publish("delayed-trains", stopAsJson);
          RemoteCache<String, String> delayed = client.getCache(DELAYED_TRAINS_CACHE_NAME);
          delayed.putAsync(stop.train.getName(), stop.train.getName());
        }
      };

    ContinuousQuery<String, Stop> continuousQuery = Search.getContinuousQuery(stations);
    continuousQuery.removeAllListeners();
    continuousQuery.addContinuousQueryListener(query, listener);
  }</code></pre>
        </div>
      </li>
      <li>From command line, change directory to <code>delayed-listener</code> and redeploy with <code>mvn fabric8:deploy</code></li>
      <li>Go to <kbd>delayed-dashboard</kbd> module and launch <code>DelayedDashboard</code> main</li>
      <li>Monitor the delayed trains !</li>
    </ul>
  </section>


  <h2>Ex6 :: Delayed trains positions</h2>

  <section id="inmemory">
    <img src="img/InMemoryLayer.png" alt="Inmemory Layer" class="img-rounded">
    <ul style="list-style: decimal;">
      <li>Open <kbd>DelayedTrains</kbd> class in the <kbd>delayed-trains</kbd> module</li>
      <li><kbd>TODO 1</kbd><br/>
        Modify the EventBus bridge <kbd>options</kbd> to allow sending messages to the browser.
        Use <kbd>addOutboundPermitted</kbd> method to add a new instance of <kbd>PermittedOptions</kbd> for
        <kbd>DELAYED_TRAINS_POSITIONS_ADDRESS</kbd>.<br/>
        <a class="btn btn-info" role="button" onclick="$('#array-sol-26').toggle();">Show/Hide Solution</a>
        <div id="array-sol-26" style="display:none;">
          <pre><code class="java">options.addOutboundPermitted(new PermittedOptions().setAddress(DELAYED_TRAINS_POSITIONS_ADDRESS));</code></pre>
        </div>
      </li>
      <li><kbd>TODO 2</kbd><br/>
        Use <kbd>eventBus.publish()</kbd> method to publish the asynchronous result to the
        <kbd>DELAYED_TRAINS_POSITIONS_ADDRESS</kbd> address<br/>
        <a class="btn btn-info" role="button" onclick="$('#array-sol-25').toggle();">Show/Hide Solution</a>
        <div id="array-sol-25" style="display:none;">
          <pre><code class="java">vertx.eventBus().publish(DELAYED_TRAINS_POSITIONS_ADDRESS, ar.result());</code></pre>
        </div>
      </li>
      <li><kbd>TODO 3</kbd><br/>
        Create a Ickle query with the query factory. Ickle query are JPA like syntax queries.<br/>
        An example of query : <br/>
        <code>select tx.transactionId, tx.amount, tx.description from com.acme.Transaction tx
          where amount > 10 and description = :desc</code>.<br/>
        The parameter <code>desc</code> is replaced using <code>setParameter</code> method.<br/>
        Create a query to get trains ids for all trains positions with a given train name.<br/>
        <a class="btn btn-info" role="button" onclick="$('#array-sol-23').toggle();">Show/Hide Solution</a>
        <div id="array-sol-23" style="display:none;">
              <pre><code class="java">Query query = queryFactory.create("select tp.trainId from workshop.model.TrainPosition tp where name = :trainName");
query.setParameter("trainName", trainName);</code></pre>
        </div>
      </li>
      <li><kbd>TODO 4</kbd><br/>
        Call the query and get the result<br/>
        <a class="btn btn-info" role="button" onclick="$('#array-sol-24').toggle();">Show/Hide Solution</a>
        <div id="array-sol-24" style="display:none;">
          <pre><code class="java">List< Object[]> trains = query.list();</code></pre>
        </div>
      </li>
    </ul>
    <div>
      <a class="btn btn-danger" role="button" onclick="$('#array-sol-5').toggle();">Show/Hide Solution</a>
      <div id="array-sol-5" style="display:none;">
        <div class="alert alert-info" role="alert">
          You can deploy the solution by either of these two methods:
          <ul>
            <li>Copy/pasting the code and call: <code>mvn fabric8:deploy</code></li>
            <li>Or simply call <code>mvn fabric8:deploy -Psolution</code></li>
          </ul>
        </div>
        <pre>
          <code class="java">  @Override
  public void start(Future<Void> future) throws Exception {
    Router router = Router.router(vertx);

    router.get(DELAYED_TRAINS_POSITIONS_URI).blockingHandler(this::positionsHandler);

    SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
    BridgeOptions options = new BridgeOptions();
    options.addOutboundPermitted(new PermittedOptions().setAddress(DELAYED_TRAINS_POSITIONS_ADDRESS));
    sockJSHandler.bridge(options);
    router.route("/eventbus/*").handler(sockJSHandler);

    router.get(LISTEN_URI).handler(this::listen);

    vertx.<RemoteCacheManager>rxExecuteBlocking(fut -> fut.complete(createMgmtClient()))
      .doOnSuccess(remoteClient -> mgmtClient = remoteClient)
      .flatMap(z -> {
        return vertx.<RemoteCacheManager>rxExecuteBlocking(fut -> fut.complete(createQueryClient()));
      })
      .doOnSuccess(remoteClient -> queryClient = remoteClient)
      .flatMap(v -> {
        return vertx.createHttpServer()
          .requestHandler(router::accept)
          .rxListen(8080)
          .doOnSuccess(server -> log.info("HTTP server started"))
          .doOnError(t -> log.log(Level.SEVERE, "HTTP server failed to start", t))
          .<Void>map(server -> null); // Ignore result
      })
      .subscribe(RxHelper.toSubscriber(future));
  }

  private void publishPositions() {
    vertx.<String>executeBlocking(fut -> fut.complete(positions()), ar -> {
      if (ar.succeeded()) {
        vertx.eventBus().publish(DELAYED_TRAINS_POSITIONS_ADDRESS, ar.result());
      }
    });
  }

  private String getTrainId(Map.Entry< String, String> entry, RemoteCache< String, TrainPosition> positionsCache) {
    if (!entry.getValue().isEmpty())
      return entry.getValue();

    String trainName = entry.getKey();
    QueryFactory queryFactory = Search.getQueryFactory(positionsCache);

    Query query = queryFactory.create("select tp.trainId from workshop.model.TrainPosition tp where name = :trainName");
    query.setParameter("trainName", trainName);

    List<Object[]> trains = query.list();

    Iterator<Object[]> it = trains.iterator();
    if (it.hasNext()) {
      // Not accurate but simplest of methods
      String trainId = (String) it.next()[0];
      trainIds.put(trainName, trainId);
      return trainId;
    }

    return null;
  }</code></pre>
      </div>
      <ul>
        <li>From command line, change directory to <code>delayed-trains</code> and redeploy with
          <code>mvn fabric8:deploy</code></li>
        <li>Relaunch <code>DelayedDashboard</code> from the previous exercise so that data injection is started.</li>
        <li>Go to the board <a href="http://localhost:3000/" target="_target">front-end app</a></li>
        <li>Monitor delayed trains !</li>
      </ul>
    </div>
  </section>

</div> <!-- /container -->
<br/><br/>

<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>

</body></html>
